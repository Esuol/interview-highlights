<!DOCTYPE html>
<html lang="zh-hans">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React supported libraries &amp; Integration | Hello, World.</title>
    <meta name="description" content="📦 🎨 一个面向 RESTful API 设计的开箱即用主题。">
    <link rel="icon" href="/interview-highlights/logo.png">
  <link rel="manifest" href="/interview-highlights/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/interview-highlights/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/interview-highlights/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/interview-highlights/assets/css/styles.90509994.css" as="style"><link rel="preload" href="/interview-highlights/assets/js/app.90509994.js" as="script"><link rel="preload" href="/interview-highlights/assets/js/23.23662571.js" as="script"><link rel="preload" href="/interview-highlights/assets/css/1.styles.f5fc753a.css" as="style"><link rel="preload" href="/interview-highlights/assets/js/1.f5fc753a.js" as="script"><link rel="prefetch" href="/interview-highlights/assets/js/10.2666685c.js"><link rel="prefetch" href="/interview-highlights/assets/js/11.f889b639.js"><link rel="prefetch" href="/interview-highlights/assets/js/12.21085dd8.js"><link rel="prefetch" href="/interview-highlights/assets/js/13.ab221351.js"><link rel="prefetch" href="/interview-highlights/assets/js/14.2a85d08e.js"><link rel="prefetch" href="/interview-highlights/assets/js/15.0cf0f235.js"><link rel="prefetch" href="/interview-highlights/assets/js/16.2e6030af.js"><link rel="prefetch" href="/interview-highlights/assets/js/17.7eeddb55.js"><link rel="prefetch" href="/interview-highlights/assets/js/18.07fc2c9d.js"><link rel="prefetch" href="/interview-highlights/assets/js/19.d32f3488.js"><link rel="prefetch" href="/interview-highlights/assets/js/2.d1d0e409.js"><link rel="prefetch" href="/interview-highlights/assets/js/20.68ffcd9b.js"><link rel="prefetch" href="/interview-highlights/assets/js/21.e00b91df.js"><link rel="prefetch" href="/interview-highlights/assets/js/22.fa4e7ac6.js"><link rel="prefetch" href="/interview-highlights/assets/js/24.1537334f.js"><link rel="prefetch" href="/interview-highlights/assets/js/25.f041d3fc.js"><link rel="prefetch" href="/interview-highlights/assets/js/26.56cade79.js"><link rel="prefetch" href="/interview-highlights/assets/js/27.cbf78ce9.js"><link rel="prefetch" href="/interview-highlights/assets/js/3.68e9c18f.js"><link rel="prefetch" href="/interview-highlights/assets/js/4.540e282a.js"><link rel="prefetch" href="/interview-highlights/assets/js/5.fa4d2229.js"><link rel="prefetch" href="/interview-highlights/assets/js/6.0a5630f8.js"><link rel="prefetch" href="/interview-highlights/assets/js/7.062ea84b.js"><link rel="prefetch" href="/interview-highlights/assets/js/8.9d86a00f.js"><link rel="prefetch" href="/interview-highlights/assets/js/9.7bd38c23.js">
    <link rel="stylesheet" href="/interview-highlights/assets/css/styles.90509994.css"><link rel="stylesheet" href="/interview-highlights/assets/css/1.styles.f5fc753a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme__container sidebar-open"><div class="row"><div class="col-md-2"><div class="sidebar"><div class="group"><div class="group__title">选择语言</div><div class="group__body"><!----><div name="/" class="group__category category"><div class="category__label"><a href="/interview-highlights/" class="router-link-active">English</a></div></div><div name="/zh/configurations/js/react-part8.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part8.html" class="router-link-exact-active router-link-active">简体中文</a></div></div></div></div><div class="group"><div class="group__title">home</div><div class="group__body"><div class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/" class="router-link-active">Homepage</a></div></div></div></div><div class="group"><div class="group__title">getting-started</div><div class="group__body"><div class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/getting-started/">起步</a></div></div><div class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/getting-started/#诉说">诉说</a></div></div><div class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/getting-started/#构建于">构建于</a></div></div></div></div><div class="group"><div class="group__title">configurations</div><div class="group__body"><!----><div name="/zh/configurations/css/advanced.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/css/advanced.html">Css进阶</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/advanced.html#可以通过哪些方法优化-css3-animation-渲染？">可以通过哪些方法优化 Css3 Animation 渲染？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/advanced.html#响应式布局原理？">响应式布局原理？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/advanced.html#响应式布局的实现方案">响应式布局的实现方案</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/advanced.html#如何选择屏幕大小分割点">如何选择屏幕大小分割点</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/advanced.html#普通元素的栅格布局">普通元素的栅格布局</a></div></div></div><div name="/zh/configurations/css/" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/css/">Css基础</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#css-加载方式有几种？">Css 加载方式有几种？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#link和-import的区别？">Link和@Import的区别？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#css-选择器常见的有几种？">Css 选择器常见的有几种？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#id-选择器和-class-使用场景是什么？">Id 选择器和 Class 使用场景是什么？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#charset-有什么作用？">@Charset 有什么作用？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#简述-src-和-href-的区别？">简述 Src 和 Href 的区别？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#块级元素和行内元素分别有哪些？">块级元素和行内元素分别有哪些？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#ie-盒模型和-w3c-盒模型有什么区别">Ie 盒模型和 W3c 盒模型有什么区别?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#在什么场景下会出现外边距合并？">在什么场景下会出现外边距合并？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#line-height-2和line-height-200-区别">Line-Height:2和Line-Height:200%区别?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#让一个元素“看不见”有几种方式？有什么区别？">让一个元素“看不见”有几种方式？有什么区别？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#float-关于浮动">Float 关于浮动</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#列举你了解的-html5新特性？">列举你了解的 Html5新特性？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/#css3选择器">Css3选择器</a></div></div></div><div name="/zh/configurations/css/selector.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/css/selector.html">选择器</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/selector.html#伪类选择器？">伪类选择器？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/selector.html#伪元素和伪类的区别？">伪元素和伪类的区别？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/selector.html#选择器的优先级是如何计算的？">选择器的优先级是如何计算的？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/selector.html#什么是-css-继承？哪些属性能继承，哪些不能？">什么是 Css 继承？哪些属性能继承，哪些不能？</a></div></div></div><div name="/zh/configurations/css/unit.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/css/unit.html">Css值和单位</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/unit.html#你有没有使用过视网膜分辨率的图形？当中使用什么技术？">你有没有使用过视网膜分辨率的图形？当中使用什么技术？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/css/unit.html#px，em，rem，vw-有什么区别？">Px，Em，Rem，Vw 有什么区别？</a></div></div></div><div name="/zh/configurations/html/" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/html/">Html 相关</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/html/#关于doctype">关于Doctype</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/html/#关于-html">关于 Html</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/html/#关于meta">关于Meta</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/html/#post-和-get-方式提交数据有什么区别？">Post 和 Get 方式提交数据有什么区别？</a></div></div></div><div name="/zh/configurations/js/es678.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/es678.html">Es678</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/es678.html#es678">Es678</a></div></div></div><div name="/zh/configurations/js/process-one.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/process-one.html">Jsvascript</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#_1-2-3-map-parseint-what-why">['1', '2', '3'].Map(Parseint) What &amp; Why ?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#什么是防抖和节流？有什么区别？如何实现？">什么是防抖和节流？有什么区别？如何实现？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#介绍下深度优先遍历和广度优先遍历，如何实现？">介绍下深度优先遍历和广度优先遍历，如何实现？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#请分别用深度优先思想和广度优先思想实现一个拷贝函数？">请分别用深度优先思想和广度优先思想实现一个拷贝函数？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#es5-es6-的继承除了写法以外还有什么区别？">Es5/Es6 的继承除了写法以外还有什么区别？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#js异步解决方案的发展历程以及优缺点。">Js异步解决方案的发展历程以及优缺点。</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#_4-async-await">4 Async/Await</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#如何实现一个-new">如何实现一个 New</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#object-create">Object.Create</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#简单讲解一下-http2-的多路复用">简单讲解一下 Http2 的多路复用</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#谈谈你对-tcp-三次握手和四次挥手的理解">谈谈你对 Tcp 三次握手和四次挥手的理解</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#：a、b-机器正常连接后，b-机器突然重启，问-a-此时处于-tcp-什么状态">：A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 Tcp 什么状态</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-one.html#有以下-3-个判断数组的方法，请分别介绍它们之间的区别和优劣">有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</a></div></div></div><div name="/zh/configurations/js/process-two.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/process-two.html">进阶Js</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#说说浏览器和-node-事件循环的区别">说说浏览器和 Node 事件循环的区别</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？。">全局作用域中，用 Const 和 Let 声明的变量不在 Window 上，那到底在哪里？如何去获取？。</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#cookie-和-token-都存放在-header-中，为什么不会劫持-token？-31">Cookie 和 Token 都存放在 Header 中，为什么不会劫持 Token？ #31</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#请把俩个数组-a1-a2-b1-b2-c1-c2-d1-d2-和-a-b-c-d-，合并为-a1-a2-a-b1-b2-b-c1-c2-c-d1-d2-d-。">请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#改造下面的代码，使之输出0-9，写出你能想到的所有解法。">改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#下面的代码打印什么内容，为什么？">下面的代码打印什么内容，为什么？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#浏览器缓存读取规则">浏览器缓存读取规则</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#使用迭代的方式实现-flatten-函数。">使用迭代的方式实现 Flatten 函数。</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#下面代码中-a-在什么情况下会打印-1？">下面代码中 A 在什么情况下会打印 1？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#下面代码输出什么">下面代码输出什么?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#实现一个-sleep-函数">实现一个 Sleep 函数</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果">使用 Sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#介绍-https-握手过程">介绍 HTTPS 握手过程</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#call-和-apply-的区别是什么，哪个性能更好一些">Call 和 Apply 的区别是什么，哪个性能更好一些</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片？">为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 Gif 图片？</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/process-two.html#实现-5-add-3-minus-2-功能">实现 (5).Add(3).Minus(2) 功能</a></div></div></div><div name="/zh/configurations/js/react-part1.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part1.html">React 第一部分</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part1.html#react-第一部分">React 第一部分</a></div></div></div><div name="/zh/configurations/js/react-part10.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part10.html">React Internationalization</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part10.html#react-internationalization">React Internationalization</a></div></div></div><div name="/zh/configurations/js/react-part11.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part11.html">Miscellaneous</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#miscellaneous">Miscellaneous</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#reselect-库的主要功能有哪些">Reselect 库的主要功能有哪些?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#举一个-reselect-用法的例子">举一个 Reselect 用法的例子?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#redux-中的-action-是什么">Redux 中的 Action 是什么?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#在-react-中-statics-对象是否能与-es6-类一起使用">在 React 中 Statics 对象是否能与 Es6 类一起使用?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#redux-只能与-react-一起使用么">Redux 只能与 React 一起使用么?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#您是否需要使用特定的构建工具来使用-redux">您是否需要使用特定的构建工具来使用 Redux ?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#redux-form-的-initialvalues-如何从状态更">Redux Form 的 Initialvalues 如何从状态更</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part11.html#react-是如何为一个属性声明不同的类型">React 是如何为一个属性声明不同的类型?</a></div></div></div><div name="/zh/configurations/js/react-part2.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part2.html">React 第二部分</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part2.html#react-第二部分">React 第二部分</a></div></div></div><div name="/zh/configurations/js/react-part3.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part3.html">React 第三部分</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part3.html#react-第三部分">React 第三部分</a></div></div></div><div name="/zh/configurations/js/react-part4.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part4.html">React 第四部分</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part4.html#react-第四部分">React 第四部分</a></div></div></div><div name="/zh/configurations/js/react-part5.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part5.html">React Redux</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part5.html#react-redux">React Redux</a></div></div></div><div name="/zh/configurations/js/react-part6.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part6.html">React Router</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part6.html#react-router">React Router</a></div></div></div><div name="/zh/configurations/js/react-part7.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part7.html">React Native</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part7.html#react-native">React Native</a></div></div></div><div name="/zh/configurations/js/react-part8.html" class="group__category category category--selected category--active"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part8.html" class="router-link-exact-active router-link-active">React Supported Libraries &amp; Integration</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part8.html#react-supported-libraries-integration">React Supported Libraries &amp; Integration</a></div></div></div><div name="/zh/configurations/js/react-part9.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/react-part9.html">React Testing</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/react-part9.html#react-testing">React Testing</a></div></div></div><div name="/zh/configurations/js/vue.html" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/js/vue.html">Vue</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/js/vue.html#vue">Vue</a></div></div></div><div name="/zh/configurations/others/" class="group__category category"><div class="category__label"><a href="/interview-highlights/zh/configurations/others/">前端需要注意哪些 Seo?</a></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/others/#前端需要注意哪些-seo">前端需要注意哪些 Seo?</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/others/#请谈一下你对网页标准和标准制定机构重要性的理解。">请谈一下你对网页标准和标准制定机构重要性的理解。</a></div></div><div class="category__headers"><div class="category__header-item"><a href="/interview-highlights/zh/configurations/others/#常见-web-安全及防护原理？">常见 Web 安全及防护原理？</a></div></div></div></div></div></div></div><div class="col-md-10"><div class="page__container"><div class="content custom"><h2 id="react-supported-libraries-integration"><a href="#react-supported-libraries-integration" aria-hidden="true" class="header-anchor">#</a> React supported libraries &amp; Integration</h2><h3 id="什么是-reselect-以及它是如何工作的"><a href="#什么是-reselect-以及它是如何工作的" aria-hidden="true" class="header-anchor">#</a> 什么是 Reselect 以及它是如何工作的?</h3><p>Reselect是一个选择器库（用于 Redux ），它使用memoization概念。它最初编写用于计算类似 Redux 的应用程序状态的派生数据，但它不能绑定到任何体系结构或库。</p><p>Reselect 保留最后一次调用的最后输入/输出的副本，并仅在其中一个输入发生更改时重新计算结果。如果连续两次提供相同的输入，则 Reselect 将返回缓存的输出。它的 memoization 和缓存是完全可定制的。</p><h3 id="什么是-flow"><a href="#什么是-flow" aria-hidden="true" class="header-anchor">#</a> 什么是 Flow?</h3><p>Flow 是一个静态类型检查器，旨在查找 JavaScript 中的类型错误。与传统类型系统相比，Flow 类型可以表达更细粒度的区别。例如，与大多数类型系统不同，Flow 能帮助你捕获涉及 null 的错误。</p><h3 id="flow-和-proptypes-有什么区别"><a href="#flow-和-proptypes-有什么区别" aria-hidden="true" class="header-anchor">#</a> Flow 和 PropTypes 有什么区别?</h3><p>Flow 是一个静态分析工具（静态检查器），它使用该语言的超集，允许你在所有代码中添加类型注释，并在编译时捕获整个类的错误。PropTypes 是一个基本类型检查器（运行时检查器），已经被添加到 React 中。除了检查传递给给定组件的属性类型外，它不能检查其他任何内容。如果你希望对整个项目进行更灵活的类型检查，那么 Flow/TypeScript 是更合适的选择。</p><h3 id="在-react-中如何使用-font-awesome-图标"><a href="#在-react-中如何使用-font-awesome-图标" aria-hidden="true" class="header-anchor">#</a> 在 React 中如何使用 Font Awesome 图标?</h3><p>接下来的步骤将在 React 中引入 Font Awesome：</p><p>安装 font-awesome:</p><div class="language-js extra-class"><pre class="language-js"><code>$ npm install <span class="token operator">--</span>save font<span class="token operator">-</span>awesome
</code></pre></div><p>在 index.js 文件中导入 font-awesome:</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">'font-awesome/css/font-awesome.min.css'</span>
</code></pre></div><p>在 className 中添加 Font Awesome 类:</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span>i className<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'fa fa-spinner'</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="什么-是-react-开发者工具"><a href="#什么-是-react-开发者工具" aria-hidden="true" class="header-anchor">#</a> 什么 是 React 开发者工具?</h3><p>React Developer Tools 允许您检查组件层次结构，包括组件属性和状态。它既可以作为浏览器扩展（用于 Chrome 和 Firefox ），也可以作为独立的应用程序（用于其他环境，包括 Safari、IE 和 React Native）。</p><p>可用于不同浏览器或环境的官方扩展。</p><p>Chrome插件</p><p>Firefox插件</p><p>独立应用 （ Safari，React Native 等）</p><h3 id="在-chrome-中为什么-devtools-没有加载本地文件"><a href="#在-chrome-中为什么-devtools-没有加载本地文件" aria-hidden="true" class="header-anchor">#</a> 在 Chrome 中为什么 DevTools 没有加载本地文件?</h3><p>如果您在浏览器中打开了本地 HTML 文件（file://...），则必须先打开Chrome Extensions并选中“允许访问文件URL”。</p><h3 id="如何在-react-中使用-polymer"><a href="#如何在-react-中使用-polymer" aria-hidden="true" class="header-anchor">#</a> 如何在 React 中使用 Polymer?</h3><p>创建 Polymer 元素：</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>import<span class="token punctuation">'</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>../../bower_components/polymer/polymer.html<span class="token punctuation">'</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">Polymer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  is<span class="token punctuation">:</span> <span class="token string">'calender-element'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">ready</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'I am a calender'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>通过在 HTML 文档中导入 Polymer 组件，来创建该组件对应的标签。例如，在 React 应用程序的 index.html 文件中导入。</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>import<span class="token punctuation">'</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>./src/polymer-components/calender-element.html<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在 JSX 文件中使用该元素：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>calender<span class="token operator">-</span>element <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> MyComponent
</code></pre></div><h3 id="与-vue-js-相比，react-有哪些优势"><a href="#与-vue-js-相比，react-有哪些优势" aria-hidden="true" class="header-anchor">#</a> 与 Vue.js 相比，React 有哪些优势?</h3><p>与 Vue.js 相比，React 具有以下优势：</p><p>在大型应用程序开发中提供更大的灵活性。</p><p>更容易测试。</p><p>更适合创建移动端应用程序。</p><p>提供更多的信息和解决方案。</p><h3 id="为什么-react-选项卡不会显示在-devtools-中"><a href="#为什么-react-选项卡不会显示在-devtools-中" aria-hidden="true" class="header-anchor">#</a> 为什么 React 选项卡不会显示在 DevTools 中?</h3><p>当页面加载时，React DevTools设置一个名为__REACT_DEVTOOLS_GLOBAL_HOOK__的全局变量，然后 React 在初始化期间与该钩子通信。如果网站没有使用 React，或者如果 React 无法与 DevTools 通信，那么它将不会显示该选项卡。</p><h3 id="什么是-styled-components"><a href="#什么是-styled-components" aria-hidden="true" class="header-anchor">#</a> 什么是 Styled Components?</h3><p>styled-components 是一个用于样式化 React 应用程序的 JavaScript 库。 它删除了样式和组件之间的映射，并允许您在 js 中编写 CSS。</p><h3 id="举一个-styled-components-的例子"><a href="#举一个-styled-components-的例子" aria-hidden="true" class="header-anchor">#</a> 举一个 Styled Components 的例子?</h3><p>让我们创建具有特定样式的Title和Wrapper组件。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> styled <span class="token keyword">from</span> <span class="token string">'styled-components'</span>

<span class="token comment">// Create a &lt;Title&gt; component that renders an &lt;h1&gt; which is centered, red and sized at 1.5em</span>
<span class="token keyword">const</span> Title <span class="token operator">=</span> styled<span class="token punctuation">.</span>h1<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
</span><span class="token template-punctuation string">`</span></span>

<span class="token comment">// Create a &lt;Wrapper&gt; component that renders a &lt;section&gt; with some padding and a papayawhip background</span>
<span class="token keyword">const</span> Wrapper <span class="token operator">=</span> styled<span class="token punctuation">.</span>section<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  padding: 4em;
  background: papayawhip;
</span><span class="token template-punctuation string">`</span></span>
</code></pre></div><p>Title和Wrapper变量现在是可以像任何其他 react 组件一样渲染。</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Wrapper</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Title</span><span class="token punctuation">&gt;</span></span>{'Lets start first styled component!'}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Wrapper</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="什么是-relay"><a href="#什么是-relay" aria-hidden="true" class="header-anchor">#</a> 什么是 Relay?</h3><p>Relay 是一个 JavaScript 框架，用于使用 React 视图层为 Web 应用程序提供数据层和客户端与服务器之间的通信。</p><h3 id="如何在-create-react-app-中使用-typescript"><a href="#如何在-create-react-app-中使用-typescript" aria-hidden="true" class="header-anchor">#</a> 如何在 create-react-app 中使用 TypeScript?</h3><p>当您创建一个新项目带有--scripts-version选项值为react-scripts-ts时便可将 TypeScript 引入。</p><p>生成的项目结构如下所示：</p><p>my-app/
├─ .gitignore
├─ images.d.ts
├─ node_modules/
├─ public/
├─ src/
│  └─ ...
├─ package.json
├─ tsconfig.json
├─ tsconfig.prod.json
├─ tsconfig.test.json
└─ tslint.json</p><h3 id="我可以导入一个-svg-文件作为-react-组件么"><a href="#我可以导入一个-svg-文件作为-react-组件么" aria-hidden="true" class="header-anchor">#</a> 我可以导入一个 SVG 文件作为 React 组件么?</h3><p>你可以直接将 SVG 作为组件导入，而不是将其作为文件加载。此功能仅在 react-scripts@2.0.0 及更高版本中可用。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ReactComponent <span class="token keyword">as</span> Logo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./logo.svg'</span>

<span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token comment">/* Logo is an actual react component */</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span>Logo <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span>
</code></pre></div><h3 id="为什么不建议使用内联引用回调或函数"><a href="#为什么不建议使用内联引用回调或函数" aria-hidden="true" class="header-anchor">#</a> 为什么不建议使用内联引用回调或函数?</h3><p>如果将 ref 回调定义为内联函数，则在更新期间它将会被调用两次。首先使用 null 值，然后再使用 DOM 元素。这是因为每次渲染的时候都会创建一个新的函数实例，因此 React 必须清除旧的 ref 并设置新的 ref。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">UserForm</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Input Value is: &quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>
     <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>input
         type<span class="token operator">=</span><span class="token string">'text'</span>
         ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input <span class="token operator">=</span> input<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">// Access DOM input in handle submit</span>
       <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">'submit'</span><span class="token operator">&gt;</span>Submit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
   <span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>但我们期望的是当组件挂载时，ref 回调只会被调用一次。一个快速修复的方法是使用 ES7 类属性语法定义函数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">UserForm</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
 <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Input Value is: &quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>

 <span class="token function-variable function">setSearchInput</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>input <span class="token operator">=</span> input
 <span class="token punctuation">}</span>

 <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>
     <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>input
         type<span class="token operator">=</span><span class="token string">'text'</span>
         ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>setSearchInput<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">// Access DOM input in handle submit</span>
       <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">'submit'</span><span class="token operator">&gt;</span>Submit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
   <span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="在-react-中什么是渲染劫持"><a href="#在-react-中什么是渲染劫持" aria-hidden="true" class="header-anchor">#</a> 在 React 中什么是渲染劫持?</h3><p>渲染劫持的概念是控制一个组件将从另一个组件输出什么的能力。实际上，这意味着你可以通过将组件包装成高阶组件来装饰组件。通过包装，你可以注入额外的属性或产生其他变化，这可能会导致渲染逻辑的更改。实际上它不支持劫持，但通过使用 HOC，你可以使组件以不同的方式工作。</p><h3 id="什么是-hoc-工厂实现"><a href="#什么是-hoc-工厂实现" aria-hidden="true" class="header-anchor">#</a> 什么是 HOC 工厂实现?</h3><p>在 React 中实现 HOC 有两种主要方式。 1.属性代理（PP）和 2.继承倒置（II）。他们遵循不同的方法来操纵WrappedComponent。</p><p>属性代理 在这种方法中，HOC 的 render 方法返回 WrappedComponent 类型的 React 元素。我们通过 HOC 收到 props，因此定义为属性代理。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ppHOC</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">PP</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>props<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>继承倒置 在这种方法中，返回的 HOC 类（Enhancer）扩展了 WrappedComponent 。它被称为继承反转，因为它不是扩展一些 Enhancer 类的 WrappedComponent，而是由 Enhancer 被动扩展。 通过这种方式，它们之间的关系似乎是逆的。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">iiHOC</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">Enhancer</span> <span class="token keyword">extends</span> <span class="token class-name">WrappedComponent</span> <span class="token punctuation">{</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="如何传递数字给-react-组件"><a href="#如何传递数字给-react-组件" aria-hidden="true" class="header-anchor">#</a> 如何传递数字给 React 组件?</h3><p>传递数字时你应该使用 {}，而传递字符串时还需要使用引号：</p><div class="language-js extra-class"><pre class="language-js"><code>React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>User age<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">}</span> department<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&quot;IT&quot;</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="我需要将所有状态保存到-redux-中吗？我应该使用-react-的内部状态吗"><a href="#我需要将所有状态保存到-redux-中吗？我应该使用-react-的内部状态吗" aria-hidden="true" class="header-anchor">#</a> 我需要将所有状态保存到 Redux 中吗？我应该使用 react 的内部状态吗?</h3><p>这取决于开发者的决定。即开发人员的工作是确定应用程序的哪种状态，以及每个状态应该存在的位置，有些用户喜欢将每一个数据保存在 Redux 中，以维护其应用程序的完全可序列化和受控。其他人更喜欢在组件的内部状态内保持非关键或UI状态，例如“此下拉列表当前是否打开”。</p><p>以下是确定应将哪种数据放入Redux的主要规则：</p><p>应用程序的其他部分是否关心此数据？</p><p>您是否需要能够基于此原始数据创建更多派生数据？</p><p>是否使用相同的数据来驱动多个组件？</p><p>能够将此状态恢复到给定时间点（即时间旅行调试）是否对您有价值？</p><p>您是否要缓存数据（即，如果已经存在，则使用处于状态的状态而不是重新请求它）？</p><h3 id="在-react-中-registerserviceworker-的用途是什么"><a href="#在-react-中-registerserviceworker-的用途是什么" aria-hidden="true" class="header-anchor">#</a> 在 React 中 registerServiceWorker 的用途是什么?</h3><p>默认情况下，React 会为你创建一个没有任何配置的 service worker。Service worker 是一个 Web API，它帮助你缓存资源和其他文件，以便当用户离线或在弱网络时，他/她仍然可以在屏幕上看到结果，因此，它可以帮助你建立更好的用户体验，这是你目前应该了解的关于 Service worker 的内容。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> registerServiceWorker <span class="token keyword">from</span> <span class="token string">'./registerServiceWorker'</span><span class="token punctuation">;</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">registerServiceWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="react-memo-函数是什么"><a href="#react-memo-函数是什么" aria-hidden="true" class="header-anchor">#</a> React memo 函数是什么?</h3><p>当类组件的输入属性相同时，可以使用 pureComponent 或 shouldComponentUpdate 来避免组件的渲染。现在，你可以通过把函数组件包装在 React.memo 中来实现相同的功能。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">/* only rerenders if props change */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="react-lazy-函数是什么"><a href="#react-lazy-函数是什么" aria-hidden="true" class="header-anchor">#</a> React lazy 函数是什么?</h3><p>使用 React.lazy 函数允许你将动态导入的组件作为常规组件进行渲染。当组件开始渲染时，它会自动加载包含 OtherComponent 的包。它必须返回一个 Promise，该 Promise 解析后为一个带有默认导出 React 组件的模块。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意： React.lazy 和 Suspense 还不能用于服务端渲染。如果要在服务端渲染的应用程序中进行代码拆分，我们仍然建议使用 React Loadable。</p><h3 id="如何使用-setstate-防止不必要的更新"><a href="#如何使用-setstate-防止不必要的更新" aria-hidden="true" class="header-anchor">#</a> 如何使用 setState 防止不必要的更新?</h3><p>你可以把状态的当前值与已有的值进行比较，并决定是否重新渲染页面。如果没有更改，你需要返回 null 以阻止渲染，否则返回最新的状态值。例如，用户配置信息组件将按以下方式实现条件渲染：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">getUserProfile</span> <span class="token operator">=</span> <span class="token parameter">user</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> latestAddress <span class="token operator">=</span> user<span class="token punctuation">.</span>address<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>address <span class="token operator">===</span> latestAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> latestAddress <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="如何在-react-16-版本中渲染数组、字符串和数值"><a href="#如何在-react-16-版本中渲染数组、字符串和数值" aria-hidden="true" class="header-anchor">#</a> 如何在 React 16 版本中渲染数组、字符串和数值?</h3><p>Arrays: 与旧版本不同的是，在 React 16 中你不需要确保 render 方法必须返回单个元素。通过返回数组，你可以返回多个没有包装元素的同级元素。例如，让我们看看下面的开发人员列表：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">ReactJSDevs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>
    <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token string">&quot;1&quot;</span><span class="token operator">&gt;</span>John<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token string">&quot;2&quot;</span><span class="token operator">&gt;</span>Jackie<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token string">&quot;3&quot;</span><span class="token operator">&gt;</span>Jordan<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你还可以将此数组项合并到另一个数组组件中：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">JSDevs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Brad<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Brodge<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ReactJSDevs<span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Brandon<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Strings and Numbers: 在 render 方法中，你也可以返回字符串和数值类型：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// String</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token string">'Welcome to ReactJS questions'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Number</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token number">2018</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="如何在-react-类中使用类字段声明语法"><a href="#如何在-react-类中使用类字段声明语法" aria-hidden="true" class="header-anchor">#</a> 如何在 React 类中使用类字段声明语法?</h3><p>使用类字段声明可以使 React 类组件更加简洁。你可以在不使用构造函数的情况下初始化本地状态，并通过使用箭头函数声明类方法，而无需额外对它们进行绑定。让我们以一个 counter 示例来演示类字段声明，即不使用构造函数初始化状态且不进行方法绑定：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">handleIncrement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">handleDecrement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>value <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value<span class="token punctuation">}</span>

        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleIncrement<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleDecrement<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">-</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="什么是-hooks"><a href="#什么是-hooks" aria-hidden="true" class="header-anchor">#</a> 什么是 hooks?</h3><p>Hooks 是一个新的草案，它允许你在不编写类的情况下使用状态和其他 React 特性。让我们来看一个 useState 钩子示例：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Declare a new state variable, which we'll call &quot;count&quot;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Click me
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="hooks-需要遵循什么规则"><a href="#hooks-需要遵循什么规则" aria-hidden="true" class="header-anchor">#</a> Hooks 需要遵循什么规则?</h3><p>为了使用 hooks，你需要遵守两个规则：</p><p>仅在顶层的 React 函数调用 hooks。也就是说，你不能在循环、条件或内嵌函数中调用 hooks。这将确保每次组件渲染时都以相同的顺序调用 hooks，并且它会在多个 useState 和 useEffect 调用之间保留 hooks 的状态。</p><p>仅在 React 函数中调用 hooks。例如，你不能在常规的 JavaScript 函数中调用 hooks。</p><h3 id="如何确保钩子遵循正确的使用规则"><a href="#如何确保钩子遵循正确的使用规则" aria-hidden="true" class="header-anchor">#</a> 如何确保钩子遵循正确的使用规则?</h3><p>React 团队发布了一个名为eslint-plugin-react-hooks的 ESLint 插件，它实施了这两个规则。您可以使用以下命令将此插件添加到项目中，</p><div class="language-t extra-class"><pre class="language-text"><code>npm install eslint-plugin-react-hooks@next
</code></pre></div><p>并在您的 ESLint 配置文件中应用以下配置：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Your ESLint configuration</span>
<span class="token punctuation">{</span>
  <span class="token string">&quot;plugins&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// ...</span>
    <span class="token string">&quot;react-hooks&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">&quot;rules&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token string">&quot;react-hooks/rules-of-hooks&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;error&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="flux-和-redux-之间有什么区别"><a href="#flux-和-redux-之间有什么区别" aria-hidden="true" class="header-anchor">#</a> Flux 和 Redux 之间有什么区别?</h3><p>以下是 Flux 和 Redux 之间的主要区别</p><p>Flux	                     Redux</p><p>状态是可变的	               状态是不可变的</p><p>Store 包含状态和更改逻辑	    存储和更改逻辑是分开的</p><p>存在多个 Store	            仅存在一个 Store</p><p>所有的 Store 都是断开连接的	  带有分层 reducers 的 Store</p><p>它有一个单独的 dispatcher	   没有 dispatcher 的概念</p><p>React 组件监测 Store	      容器组件使用连接函数</p><h3 id="react-router-v4-有什么好处"><a href="#react-router-v4-有什么好处" aria-hidden="true" class="header-anchor">#</a> React Router V4 有什么好处?</h3><p>以下是 React Router V4 模块的主要优点：</p><p>在React Router v4（版本4）中，API完全与组件有关。路由器可以显示为单个组件（），它包装特定的子路由器组件（）。</p><p>您无需手动设置历史记录。路由器模块将通过使用组件包装路由来处理历史记录。</p><p>通过仅添加特定路由器模块（Web，core 或 native）来减少应用大小。</p><h3 id="您能描述一下-componentdidcatch-生命周期方法签名吗"><a href="#您能描述一下-componentdidcatch-生命周期方法签名吗" aria-hidden="true" class="header-anchor">#</a> 您能描述一下 componentDidCatch 生命周期方法签名吗?</h3><p>在后代层级的组件抛出错误后，将调用componentDidCatch生命周期方法。该方法接收两个参数：</p><p>error: - 抛出的错误对象</p><p>info: - 具有 componentStack 键的对象，包含有关哪个组件引发错误的信息。</p><p>方法结构如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">componentDidCatch</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> info<span class="token punctuation">)</span>
</code></pre></div><h3 id="在哪些情况下，错误边界不会捕获错误"><a href="#在哪些情况下，错误边界不会捕获错误" aria-hidden="true" class="header-anchor">#</a> 在哪些情况下，错误边界不会捕获错误?</h3><p>以下是错误边界不起作用的情况：</p><p>在事件处理器内。</p><p>setTimeout 或 requestAnimationFrame 回调中的异步代码。</p><p>在服务端渲染期间。</p><p>错误边界代码本身中引发错误时。</p><h3 id="为什么事件处理器不需要错误边界"><a href="#为什么事件处理器不需要错误边界" aria-hidden="true" class="header-anchor">#</a> 为什么事件处理器不需要错误边界?</h3><p>错误边界不会捕获事件处理程序中的错误。与 render 方法或生命周期方法不同，在渲染期间事件处理器不会被执行或调用。</p><p>如果仍然需要在事件处理程序中捕获错误，请使用下面的常规 JavaScript try/catch 语句：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> error<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// Do something that could throw</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> error <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Caught an error<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Click Me<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码使用普通的 JavaScript try/catch 块而不是错误边界来捕获错误。</p><h3 id="try-catch-与错误边界有什么区别"><a href="#try-catch-与错误边界有什么区别" aria-hidden="true" class="header-anchor">#</a> try catch 与错误边界有什么区别?</h3><p>Try catch 块使用命令式代码，而错误边界则是使用在屏幕上呈现声明性代码。</p><p>例如，以下是使用声明式代码的 try/catch 块：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token function">showButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而错误边界包装的声明式代码如下：</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ErrorBoundary</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ErrorBoundary</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><p>因此，如果在组件树深处某个位置组件的 componentDidUpdate 方法中，发生了由 setState 引发的错误，它仍然会正确地冒泡到最近的错误边界。</p><h3 id="react-16-中未捕获的错误的行为是什么"><a href="#react-16-中未捕获的错误的行为是什么" aria-hidden="true" class="header-anchor">#</a> React 16 中未捕获的错误的行为是什么?</h3><p>在 React 16 中，未被任何错误边界捕获的错误将导致整个 React 组件树的卸载。这一决定背后的原因是，与其显示已损坏的界面，不如完全移除它。例如，对于支付应用程序来说，显示错误的金额比什么都不提供更糟糕。</p><h3 id="放置错误边界的正确位置是什么"><a href="#放置错误边界的正确位置是什么" aria-hidden="true" class="header-anchor">#</a> 放置错误边界的正确位置是什么?</h3><p>错误边界使用的粒度由开发人员根据项目需要决定。你可以遵循这些方法中的任何一种：</p><p>可以包装顶层路由组件以显示整个应用程序中常见的错误消息。
你还可以将单个组件包装在错误边界中，以防止它们奔溃时影响到应用程序的其余部分。</p><h3 id="从错误边界跟踪组件堆栈有什么好处"><a href="#从错误边界跟踪组件堆栈有什么好处" aria-hidden="true" class="header-anchor">#</a> 从错误边界跟踪组件堆栈有什么好处?</h3><p>除了错误消息和 JavaScript 堆栈，React 16 将使用错误边界的概念显示带有文件名和行号的组件堆栈。例如，BuggyCounter 组件显示组件堆栈信息：</p><h3 id="在定义类组件时，什么是必须的方法"><a href="#在定义类组件时，什么是必须的方法" aria-hidden="true" class="header-anchor">#</a> 在定义类组件时，什么是必须的方法?</h3><p>在类组件中 render() 方法是唯一需要的方法。也就是说，对于类组件，除了 render() 方法之外的所有方法都是可选的。</p><h3 id="render-方法可能返回的类型是什么"><a href="#render-方法可能返回的类型是什么" aria-hidden="true" class="header-anchor">#</a> render 方法可能返回的类型是什么?</h3><p>以下列表是 render 方法返回的类型：</p><p>React elements: 用于告诉 React 如何渲染 DOM 节点。它包括 HTML 元素，如 div 和用户定义的元素。</p><p>Arrays and fragments: 以数组的形式返回多个元素和包装多个元素的片段。</p><p>Portals: 将子元素渲染到不同的 DOM 子树中。</p><p>String and numbers: 在 DOM 中将字符串和数字都作为文本节点进行呈现。</p><p>Booleans or null: 不会渲染任何内容，但这些类型用于有条件地渲染内容。</p><h3 id="构造函数的主要目的是什么"><a href="#构造函数的主要目的是什么" aria-hidden="true" class="header-anchor">#</a> 构造函数的主要目的是什么?</h3><p>使用构造函数主要有两个目的：</p><p>通过将对象分配给 this.state 来初始化本地状态。</p><p>用于为组件实例绑定事件处理方法。</p><p>例如，下面的代码涵盖了上述两种情况：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Don't call this.setState() here!</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> counter<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="是否必须为-react-组件定义构造函数"><a href="#是否必须为-react-组件定义构造函数" aria-hidden="true" class="header-anchor">#</a> 是否必须为 React 组件定义构造函数?</h3><p>不，这不是强制的。也就是说，如果你不需要初始化状态且不需要绑定方法，则你不需要为 React 组件实现一个构造函数。</p><h3 id="什么是默认属性"><a href="#什么是默认属性" aria-hidden="true" class="header-anchor">#</a> 什么是默认属性?</h3><p>defaultProps 被定义为组件类上的属性，用于设置组件类默认的属性值。它只适用于 undefined 的属性，而不适用于 null 属性。例如，让我们为按钮组件创建默认的 color 属性：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

MyButton<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>
  color<span class="token punctuation">:</span> <span class="token string">'red'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>如果未设置 props.color，则会使用默认值 red。 也就是说，每当你试图访问 color 属性时，它都使用默认值。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token operator">&lt;</span>MyButton <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span> <span class="token comment">// props.color will be set to red</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>注意： 如果你提供的是 null 值，它会仍然保留 null 值。</p><h3 id="为什么不能在-componentwillunmount-中调用-setstate-方法"><a href="#为什么不能在-componentwillunmount-中调用-setstate-方法" aria-hidden="true" class="header-anchor">#</a> 为什么不能在 componentWillUnmount 中调用 setState() 方法?</h3><p>不应在 componentWillUnmount() 中调用 setState()，因为一旦卸载了组件实例，就永远不会再次装载它。</p><h3 id="getderivedstatefromerror-的目的是什么"><a href="#getderivedstatefromerror-的目的是什么" aria-hidden="true" class="header-anchor">#</a> getDerivedStateFromError 的目的是什么?</h3><p>在子代组件抛出异常后会调用此生命周期方法。它以抛出的异常对象作为参数，并返回一个值用于更新状态。该生命周期方法的签名如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
</code></pre></div><p>让我们举一个包含上述生命周期方法的错误边界示例，来说明 getDerivedStateFromError 的目的：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">ErrorBoundary</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> hasError<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Update state so the next render will show the fallback UI.</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> hasError<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>hasError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// You can render any custom fallback UI</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Something went wrong<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="当组件重新渲染时顺序执行的方法有哪些"><a href="#当组件重新渲染时顺序执行的方法有哪些" aria-hidden="true" class="header-anchor">#</a> 当组件重新渲染时顺序执行的方法有哪些?</h3><p>更新可能由属性或状态的更改引起。在重新渲染组件时，会按以下顺序调用下列方法。</p><p>static getDerivedStateFromProps()</p><p>shouldComponentUpdate()</p><p>render()</p><p>getSnapshotBeforeUpdate()</p><p>componentDidUpdate()</p><h3 id="错误处理期间调用哪些方法"><a href="#错误处理期间调用哪些方法" aria-hidden="true" class="header-anchor">#</a> 错误处理期间调用哪些方法?</h3><p>在渲染期间，生命周期方法内或任何子组件的构造函数中出现错误时，将会调用以下方法：</p><p>static getDerivedStateFromError()</p><p>componentDidCatch()</p><h3 id="displayname-类属性的用途是什么"><a href="#displayname-类属性的用途是什么" aria-hidden="true" class="header-anchor">#</a> displayName 类属性的用途是什么?</h3><p>displayName 被用于调试信息。通常，你不需要显式设置它，因为它是从定义组件的函数或类的名称推断出来的。如果出于调试目的或在创建高阶组件时显示不同的名称，可能需要显式设置它。</p><p>例如，若要简化调试，请选择一个显示名称，以表明它是 withSubscription HOC 的结果。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">WithSubscription</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
  WithSubscription<span class="token punctuation">.</span>displayName <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">WithSubscription(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> WithSubscription<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> WrappedComponent<span class="token punctuation">.</span>displayName <span class="token operator">||</span> WrappedComponent<span class="token punctuation">.</span>name <span class="token operator">||</span> <span class="token string">'Component'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="unmountcomponentatnode-方法的目的是什么"><a href="#unmountcomponentatnode-方法的目的是什么" aria-hidden="true" class="header-anchor">#</a> unmountComponentAtNode 方法的目的是什么?</h3><p>此方法可从 react-dom 包中获得，它从 DOM 中移除已装载的 React 组件，并清除其事件处理程序和状态。如果容器中没有装载任何组件，则调用此函数将不起任何作用。如果组件已卸载，则返回 true；如果没有要卸载的组件，则返回 false。该方法的签名如下：</p><div class="language-js extra-class"><pre class="language-js"><code>ReactDOM<span class="token punctuation">.</span><span class="token function">unmountComponentAtNode</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span>
</code></pre></div><h3 id="什么是代码拆分"><a href="#什么是代码拆分" aria-hidden="true" class="header-anchor">#</a> 什么是代码拆分?</h3><p>Code-Splitting 是 Webpack 和 Browserify 等打包工具所支持的一项功能，它可以创建多个 bundles，并可以在运行时动态加载。React 项目支持通过 dynamic import() 特性进行代码拆分。例如，在下面的代码片段中，它将使 moduleA.js 及其所有唯一依赖项作为单独的块，仅当用户点击 'Load' 按钮后才加载。</p><h4 id="modulea-js"><a href="#modulea-js" aria-hidden="true" class="header-anchor">#</a> moduleA.js</h4><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token string">'Hello'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span> moduleA <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="app-js"><a href="#app-js" aria-hidden="true" class="header-anchor">#</a> App.js</h4><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./moduleA'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> moduleA <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// Use moduleA</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// Handle failure</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Load<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><h3 id="严格模式有什么好处"><a href="#严格模式有什么好处" aria-hidden="true" class="header-anchor">#</a> 严格模式有什么好处?</h3><p>在下面的情况下， 将有所帮助：</p><p>使用 unsafe lifecycle methods 标识组件。</p><p>有关 legacy string ref API 用法发出警告。</p><p>检测无法预测的 side effects。</p><p>检测 legacy context API。</p><p>有关已弃用的 findDOMNode 用法的警告。</p><h3 id="什么是-keyed-fragments"><a href="#什么是-keyed-fragments" aria-hidden="true" class="header-anchor">#</a> 什么是 Keyed Fragments ?</h3><p>使用显式 React.Fragment 语法声明的片段可能具有 key 。一般用例是将集合映射到片段数组，如下所示，</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Glossary</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>dl<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>props<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
        <span class="token comment">// Without the `key`, React will fire a key warning</span>
        <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment key<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>dt<span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>term<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>dt<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>dd<span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>description<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>dd<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>dl<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="react-支持所有的-html-属性么"><a href="#react-支持所有的-html-属性么" aria-hidden="true" class="header-anchor">#</a> React 支持所有的 HTML 属性么?</h3><p>从 React 16 开始，完全支持标准或自定义 DOM 属性。由于 React 组件通常同时使用自定义和与 DOM 相关的属性，因此 React 与 DOM API 一样都使用 camelCase 约定。让我们对标准 HTML 属性采取一些措施：</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">tabIndex</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>-1<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>      // Just like node.tabIndex DOM API
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>Button<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span> // Just like node.className DOM API
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">readOnly</span><span class="token attr-value"><span class="token punctuation">=</span>{true}</span> <span class="token punctuation">/&gt;</span></span>  // Just like node.readOnly DOM API
</code></pre></div><p>除了特殊情况外，这些属性的工作方式与相应的 HTML 属性类似。它还支持所有 SVG 属性。</p><h3 id="hoc-有哪些限制"><a href="#hoc-有哪些限制" aria-hidden="true" class="header-anchor">#</a> HOC 有哪些限制?</h3><p>除了它的好处之外，高阶组件还有一些注意事项。 以下列出的几个注意事项:</p><p>1 不要在渲染方法中使用HOC： 建议不要将 HOC 应用于组件的 render 方法中的组件。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// A new version of EnhancedComponent is created on every render</span>
  <span class="token comment">// EnhancedComponent1 !== EnhancedComponent2</span>
  <span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// That causes the entire subtree to unmount/remount each time!</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>EnhancedComponent <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述代码通过重新装载，将导致该组件及其所有子组件状态丢失，会影响到性能。正确的做法应该是在组件定义之外应用 HOC ，以便仅生成一次生成的组件</p><p>2 静态方法必须复制： 将 HOC 应用于组件时，新组件不具有原始组件的任何静态方法</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Define a static method</span>
WrappedComponent<span class="token punctuation">.</span><span class="token function-variable function">staticMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
<span class="token comment">// Now apply a HOC</span>
<span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// The enhanced component has no static method</span>
<span class="token keyword">typeof</span> EnhancedComponent<span class="token punctuation">.</span>staticMethod <span class="token operator">===</span> <span class="token string">'undefined'</span> <span class="token comment">// true</span>
</code></pre></div><p>您可以通过在返回之前将方法复制到输入组件上来解决此问题</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// Must know exactly which method(s) to copy :(</span>
  Enhance<span class="token punctuation">.</span>staticMethod <span class="token operator">=</span> WrappedComponent<span class="token punctuation">.</span>staticMethod<span class="token punctuation">;</span>
  <span class="token keyword">return</span> Enhance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3 Refs 不会被往下传递 对于HOC，您需要将所有属性传递给包装组件，但这对于 refs 不起作用。这是因为 ref 并不是一个类似于 key 的属性。在这种情况下，您需要使用 React.forwardRef API。</p><h3 id="如何在-devtools-中调试-forwardrefs"><a href="#如何在-devtools-中调试-forwardrefs" aria-hidden="true" class="header-anchor">#</a> 如何在 DevTools 中调试 forwardRefs?</h3><p>React.forwardRef接受渲染函数作为参数，DevTools 使用此函数来确定为 ref 转发组件显示的内容。例如，如果您没有使用 displayName 属性命名 render 函数，那么它将在 DevTools 中显示为“ForwardRef”，</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> WrappedComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>LogProps <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> forwardedRef<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但如果你命名 render 函数，那么它将显示为 “ForwardRef(myFunction)”</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> WrappedComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>LogProps <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> forwardedRef<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>作为替代方案，您还可以为 forwardRef 函数设置 displayName 属性，</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter">Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">LogProps</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>LogProps <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> forwardedRef<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Give this component a more helpful display name in DevTools.</span>
  <span class="token comment">// e.g. &quot;ForwardRef(logProps(MyComponent))&quot;</span>
  <span class="token keyword">const</span> name <span class="token operator">=</span> Component<span class="token punctuation">.</span>displayName <span class="token operator">||</span> Component<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
  forwardRef<span class="token punctuation">.</span>displayName <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">logProps(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span>forwardRef<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="x什么时候组件的-props-属性默认为-true"><a href="#x什么时候组件的-props-属性默认为-true" aria-hidden="true" class="header-anchor">#</a> x什么时候组件的 props 属性默认为 true?</h3><p>如果没有传递属性值，则默认为 true。此行为可用，以便与 HTML 的行为匹配。例如，下面的表达式是等价的：</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyInput</span> <span class="token attr-name">autocomplete</span> <span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyInput</span> <span class="token attr-name">autocomplete</span><span class="token attr-value"><span class="token punctuation">=</span>{true}</span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>注意： 不建议使用此方法，因为它可能与 ES6 对象 shorthand 混淆（例如，{name}，它是{ name:name } 的缩写）</p><h3 id="什么是-nextjs-及其主要特征"><a href="#什么是-nextjs-及其主要特征" aria-hidden="true" class="header-anchor">#</a> 什么是 NextJS 及其主要特征?</h3><p>Next.js 是一个流行的轻量级框架，用于使用 React 构建静态和服务端渲染应用程序。它还提供样式和路由解决方案。以下是 NextJS 提供的主要功能：</p><p>默认服务端渲染</p><p>自动代码拆分以加快页面加载速度</p><p>简单的客户端路由 (基于页面)</p><p>基于 Webpack 的开发环境支持 (HMR)</p><p>能够使用 Express 或任何其他 Node.js HTTP 服务器</p><p>可自定义你自己的 Babel 和 Webpack 配置</p><h3 id="如何将事件处理程序传递给组件"><a href="#如何将事件处理程序传递给组件" aria-hidden="true" class="header-anchor">#</a> 如何将事件处理程序传递给组件?</h3><p>可以将事件处理程序和其他函数作为属性传递给子组件。它可以在子组件中使用，如下所示：</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token attr-value"><span class="token punctuation">=</span>{this.handleClick}</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="在渲染方法中使用箭头函数好么"><a href="#在渲染方法中使用箭头函数好么" aria-hidden="true" class="header-anchor">#</a> 在渲染方法中使用箭头函数好么?</h3><p>是的，你可以用。它通常是向回调函数传递参数的最简单方法。但在使用时需要优化性能。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Click happened'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Click Me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意： 组件每次渲染时，在 render 方法中的箭头函数都会创建一个新的函数，这可能会影响性能。</p><h3 id="如何防止函数被多次调用"><a href="#如何防止函数被多次调用" aria-hidden="true" class="header-anchor">#</a> 如何防止函数被多次调用?</h3><p>如果你使用一个事件处理程序，如 onClick or onScroll 并希望防止回调被过快地触发，那么你可以限制回调的执行速度。</p><p>这可以通过以下可能的方式实现：</p><p>Throttling: 基于时间的频率进行更改。例如，它可以使用 lodash 的 _.throttle 函数。</p><p>Debouncing: 在一段时间不活动后发布更改。例如，可以使用 lodash 的 _.debounce 函数。</p><p>RequestAnimationFrame throttling: 基于 requestAnimationFrame 的更改。例如，可以使用 raf-schd。</p><p>注意：_.debounce， _.throttle 和 raf-schd 都提供了一个 cancel 方法来取消延迟回调。所以需要调用 componentWillUnmount，或者对代码进行检查来保证在延迟函数有效期间内组件始终挂载。</p><h3 id="jsx-如何防止注入攻击"><a href="#jsx-如何防止注入攻击" aria-hidden="true" class="header-anchor">#</a> JSX 如何防止注入攻击?</h3><p>React DOM 会在渲染 JSX 中嵌入的任何值之前对其进行转义。因此，它确保你永远不能注入任何未在应用程序中显式写入的内容。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> name <span class="token operator">=</span> response<span class="token punctuation">.</span>potentiallyMaliciousInput<span class="token punctuation">;</span>
<span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>这样可以防止应用程序中的XSS（跨站点脚本）攻击。</p><h3 id="如何更新已渲染的元素"><a href="#如何更新已渲染的元素" aria-hidden="true" class="header-anchor">#</a> 如何更新已渲染的元素?</h3><p>通过将新创建的元素传递给 ReactDOM 的 render 方法，可以实现 UI 更新。例如，让我们举一个滴答时钟的例子，它通过多次调用 render 方法来更新时间：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>It is <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleTimeString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">setInterval</span><span class="token punctuation">(</span>tick<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="你怎么说-props-是只读的"><a href="#你怎么说-props-是只读的" aria-hidden="true" class="header-anchor">#</a> 你怎么说 props 是只读的?</h3><p>当你将组件声明为函数或类时，它决不能修改自己的属性。让我们来实现一个 capital 的函数：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">capital</span><span class="token punctuation">(</span><span class="token parameter">amount<span class="token punctuation">,</span> interest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> amount <span class="token operator">+</span> interest<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的函数称为“纯”函数，因为它不会尝试更改输入，并总是为相同的输入返回相同的结果。因此，React 有一条规则，即“所有 React 组件的行为都必须像纯函数一样”。</p><h3 id="你认为状态更新是如何合并的"><a href="#你认为状态更新是如何合并的" aria-hidden="true" class="header-anchor">#</a> 你认为状态更新是如何合并的?</h3><p>当你在组件中调用 setState() 方法时，React 会将提供的对象合并到当前状态。例如，让我们以一个使用帖子和评论详细信息的作为状态变量的 Facebook 用户为例：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      posts<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      comments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>现在，你可以独立调用 setState() 方法，单独更新状态变量：</p><div class="language-js extra-class"><pre class="language-js"><code> <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fetchPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        posts<span class="token punctuation">:</span> response<span class="token punctuation">.</span>posts
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fetchComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        comments<span class="token punctuation">:</span> response<span class="token punctuation">.</span>comments
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>如上面的代码段所示，this.setState({comments}) 只会更新 comments 变量，而不会修改或替换 posts 变量。</p><h3 id="如何将参数传递给事件处理程序"><a href="#如何将参数传递给事件处理程序" aria-hidden="true" class="header-anchor">#</a> 如何将参数传递给事件处理程序?</h3><p>在迭代或循环期间，向事件处理程序传递额外的参数是很常见的。这可以通过箭头函数或绑定方法实现。让我们以网格中更新的用户详细信息为例：</p><div class="language-html extra-class"><pre class="language-html"><code>&lt;button onClick={(e) =&gt; this.updateUser(userId, e)}&gt;Update User details<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token attr-value"><span class="token punctuation">=</span>{this.updateUser.bind(this,</span> <span class="token attr-name">userId)}</span><span class="token punctuation">&gt;</span></span>Update User details<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在这两种方法中，合成参数 e 作为第二个参数传递。你需要在箭头函数中显式传递它，并使用 bind 方法自动转发它。</p><h3 id="如何防止组件渲染"><a href="#如何防止组件渲染" aria-hidden="true" class="header-anchor">#</a> 如何防止组件渲染?</h3><p>你可以基于特定的条件通过返回 null 值来阻止组件的渲染。这样它就可以有条件地渲染组件。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>props<span class="token punctuation">.</span>loggedIn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;greeting&quot;</span><span class="token operator">&gt;</span>
      welcome<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>loggedIn<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'John'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>
       <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
         <span class="token comment">//Prevent component render if it is not loggedIn</span>
         <span class="token operator">&lt;</span>Greeting loggedIn<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>loggedIn<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>UserDetails name<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
   <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>在上面的示例中，greeting 组件通过应用条件并返回空值跳过其渲染部分。</p><h3 id="安全地使用索引作为键的条件是什么"><a href="#安全地使用索引作为键的条件是什么" aria-hidden="true" class="header-anchor">#</a> 安全地使用索引作为键的条件是什么?</h3><p>有三个条件可以确保，使用索引作为键是安全的：</p><p>列表项是静态的，它们不会被计算，也不会更改。</p><p>列表中的列表项没有 ids 属性。</p><p>列表不会被重新排序或筛选。</p><h3 id="keys-是否需要全局唯一"><a href="#keys-是否需要全局唯一" aria-hidden="true" class="header-anchor">#</a> keys 是否需要全局唯一?</h3><p>数组中使用的键在其同级中应该是唯一的，但它们不需要是全局唯一的。也就是说，你可以在两个不同的数组中使用相同的键。例如，下面的 book 组件在不同的组件中使用相同的数组：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Book</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>props<span class="token punctuation">.</span>pages<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">page</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
        <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>page<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&gt;</span>
          <span class="token punctuation">{</span>page<span class="token punctuation">.</span>title<span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
      <span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> content <span class="token operator">=</span> props<span class="token punctuation">.</span>pages<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">page</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token operator">&lt;</span>div key<span class="token operator">=</span><span class="token punctuation">{</span>page<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h3<span class="token operator">&gt;</span><span class="token punctuation">{</span>page<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span>page<span class="token punctuation">.</span>content<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span>page<span class="token punctuation">.</span>pageNumber<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>index<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>hr <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>content<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="用于表单处理的流行选择是什么"><a href="#用于表单处理的流行选择是什么" aria-hidden="true" class="header-anchor">#</a> 用于表单处理的流行选择是什么?</h3><p>Formik 是一个用于 React 的表单库，它提供验证、跟踪访问字段和处理表单提交等解决方案。具体来说，你可以按以下方式对它们进行分类：</p><p>获取表单状态输入和输出的值。</p><p>表单验证和错误消息。</p><p>处理表单提交。</p><p>它用于创建一个具有最小 API 的可伸缩、性能良好的表单助手，以解决令人讨厌的问题。</p><h3 id="formik-相对于其他-redux-表单库有什么优势"><a href="#formik-相对于其他-redux-表单库有什么优势" aria-hidden="true" class="header-anchor">#</a> formik 相对于其他 redux 表单库有什么优势?</h3><p>下面是建议使用 formik 而不是 redux 表单库的主要原因：</p><p>表单状态本质上是短期的和局部的，因此不需要在 redux（或任何类型的flux库）中跟踪它。</p><p>每次按一个键，Redux-Form 都会多次调用整个顶级 Redux Reducer。这样就增加了大型应用程序的输入延迟。</p><p>经过 gzip 压缩过的 Redux-Form 为 22.5 kB，而 Formik 只有 12.7 kB。</p><h3 id="为什么不需要使用继承"><a href="#为什么不需要使用继承" aria-hidden="true" class="header-anchor">#</a> 为什么不需要使用继承?</h3><p>在 React 中，建议使用组合而不是继承来重用组件之间的代码。Props 和 composition 都为你提供了以一种明确和安全的方式自定义组件外观和行为所需的灵活性。但是，如果你希望在组件之间复用非 UI 功能，建议将其提取到单独的 JavaScript 模块中。之后的组件导入它并使用该函数、对象或类，而不需扩展它。</p><h3 id="我可以在-react-应用程序中可以使用-web-components-么"><a href="#我可以在-react-应用程序中可以使用-web-components-么" aria-hidden="true" class="header-anchor">#</a> 我可以在 React 应用程序中可以使用 web components 么?</h3><p>是的，你可以在 React 应用程序中使用 Web Components。尽管许多开发人员不会使用这种组合方式，但如果你使用的是使用 Web Components 编写的第三方 UI 组件，则可能需要这种组合。例如，让我们使用 Vaadin 提供的 Web Components 日期选择器组件：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'./App.css'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'@vaadin/vaadin-date-picker'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>vaadin<span class="token operator">-</span>date<span class="token operator">-</span>picker label<span class="token operator">=</span><span class="token string">&quot;When were you born?&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>vaadin<span class="token operator">-</span>date<span class="token operator">-</span>picker<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><h3 id="什么是动态导入"><a href="#什么是动态导入" aria-hidden="true" class="header-anchor">#</a> 什么是动态导入?</h3><p>动态导入语法是 ECMAScript 提案，目前不属于语言标准的一部分。它有望在不久的将来被采纳。在你的应用程序中，你可以使用动态导入来实现代码拆分。让我们举一个加法的例子：</p><h4 id="normal-import"><a href="#normal-import" aria-hidden="true" class="header-anchor">#</a> Normal Import</h4><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./math'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="dynamic-import"><a href="#dynamic-import" aria-hidden="true" class="header-anchor">#</a> Dynamic Import</h4><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;./math&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">math</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="什么是-loadable-组件"><a href="#什么是-loadable-组件" aria-hidden="true" class="header-anchor">#</a> 什么是 loadable 组件?</h3><p>如果你想要在服务端渲染的应用程序中实现代码拆分，建议使用 Loadable 组件，因为 React.lazy 和 Suspense 还不可用于服务器端渲染。Loadable 允许你将动态导入的组件作为常规的组件进行渲染。让我们举一个例子：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> loadable <span class="token keyword">from</span> <span class="token string">'@loadable/component'</span>

<span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> <span class="token function">loadable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，其他组件将以单独的包进行加载。</p><h3 id="什么是-suspense-组件"><a href="#什么是-suspense-组件" aria-hidden="true" class="header-anchor">#</a> 什么是 suspense 组件?</h3><p>如果父组件在渲染时包含 dynamic import 的模块尚未加载完成，在此加载过程中，你必须使用一个 loading 指示器显示后备内容。这可以使用 Suspense 组件来实现。例如，下面的代码使用 Suspense 组件：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正如上面的代码中所展示的，懒加载的组件被包装在 Suspense 组件中。</p><h3 id="什么是基于路由的代码拆分"><a href="#什么是基于路由的代码拆分" aria-hidden="true" class="header-anchor">#</a> 什么是基于路由的代码拆分?</h3><p>进行代码拆分的最佳位置之一是路由。整个页面将立即重新渲染，因此用户不太可能同时与页面中的其他元素进行交互。因此，用户体验不会受到干扰。让我们以基于路由的网站为例，使用像 React Router 和 React.lazy 这样的库：</p><div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> BrowserRouter <span class="token keyword">as</span> Router<span class="token punctuation">,</span> Route<span class="token punctuation">,</span> Switch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Suspense<span class="token punctuation">,</span> lazy <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> Home <span class="token operator">=</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./routes/Home'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> About <span class="token operator">=</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./routes/About'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Router</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Loading...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">exact</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>/about<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>About<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Router</span></span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在上面的代码中，代码拆分将发生在每个路由层级。</p><h3 id="举例说明如何使用-context"><a href="#举例说明如何使用-context" aria-hidden="true" class="header-anchor">#</a> 举例说明如何使用 context?</h3><p>Context 旨在共享可被视为全局的数据，用于 React 组件树。例如，在下面的代码中，允许手动通过一个 theme 属性来设置按钮组件的样式。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//Lets create a context with a default theme value &quot;luna&quot;</span>
<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'luna'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Create App component where it uses provider to pass theme value in the tree</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">&quot;nova&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Toolbar <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// A middle component where you don't need to pass theme prop anymore</span>
<span class="token keyword">function</span> <span class="token function">Toolbar</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ThemedButton <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Lets read theme value in the button component to use</span>
<span class="token keyword">class</span> <span class="token class-name">ThemedButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> contextType <span class="token operator">=</span> ThemeContext<span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Button theme<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="gitalk-container"><div id="gitalk-container"></div></div></div><div class="content__footer-container"><div class="content__footer"><div class="edit-link"><a href="https://github.com/sqrthree/vuepress-theme-api/edit/master/docs/zh/configurations/js/react-part8.html.md" target="_blank" rel="noopener noreferrer">Edit this page</a><svg viewBox="0 0 33 32" version="1.1" xmlns="http://www.w3.org/2000/svg" height="16" width="16"><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="github" fill="#000"><path d="M16.3,0 C7.3,0 -3.55271368e-15,7.3 -3.55271368e-15,16.3 C-3.55271368e-15,23.5 4.7,29.6 11.1,31.8 C11.9,31.9 12.2,31.4 12.2,31 L12.2,28.2 C7.7,29.2 6.7,26 6.7,26 C6,24.2 5,23.7 5,23.7 C3.5,22.7 5.1,22.7 5.1,22.7 C6.7,22.8 7.6,24.4 7.6,24.4 C9.1,26.9 11.4,26.2 12.3,25.8 C12.4,24.7 12.9,24 13.3,23.6 C9.7,23.2 5.9,21.8 5.9,15.5 C5.9,13.7 6.5,12.3 7.6,11.1 C7.4,10.7 6.9,9 7.8,6.8 C7.8,6.8 9.2,6.4 12.3,8.5 C13.6,8.1 15,8 16.4,8 C17.8,8 19.2,8.2 20.5,8.5 C23.6,6.4 25,6.8 25,6.8 C25.9,9 25.3,10.7 25.2,11.1 C26.2,12.2 26.9,13.7 26.9,15.5 C26.9,21.8 23.1,23.1 19.5,23.5 C20.1,24 20.6,25 20.6,26.5 L20.6,31 C20.6,31.4 20.9,31.9 21.7,31.8 C28.2,29.6 32.8,23.5 32.8,16.3 C32.6,7.3 25.3,0 16.3,0 L16.3,0 Z" id="Shape"></path></g></g></svg></div><time class="last-updated"><span class="prefix">Last Updated: </span><span class="time">2019-8-5 14:04:48</span></time></div></div></div></div></div></div></div>
    <script src="/interview-highlights/assets/js/app.90509994.js" defer></script><script src="/interview-highlights/assets/js/23.23662571.js" defer></script><script src="/interview-highlights/assets/js/1.f5fc753a.js" defer></script>
  </body>
</html>
